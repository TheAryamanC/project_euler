"""
Project Euler - Problem 61: Cyclical Figurate Numbers

Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are
all figurate (polygonal) numbers, and are generated by the following formulae:
Triangle	 	P_{3,n}	= n(n + 1)/2	 	1, 3, 6, 10, 15, ...
Square	 	    P_{4,n}	= n^2	 	        1, 4, 9, 16, 25, ...
Pentagonal	 	P_{5,n}	= n(3n - 1)/2	 	1, 5, 12, 22, 35, ...
Hexagonal	 	P_{6,n}	= n(2n - 1)     	1, 6, 15, 28, 45, ...
Heptagonal	 	P_{7,n}	= n(5n - 3)/2	 	1, 7, 18, 34, 55, ...
Octagonal	 	P_{8,n}	= n(3n - 2)	 	    1, 8, 21, 40, 65, ...

The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting
properties:
1. The set is cyclic (last 2 digits of each = first 2 of next)
2. Each polygonal type is represented by a different number
3. This is the only set of 4-digit numbers with this property

Find the sum of the only ordered set of six cyclic 4-digit numbers for which
each polygonal type is represented by a different number in the set.
"""

from itertools import permutations

def generate_polygonal(sides):
    nums = {}
    n = 1
    while True:
        if sides == 3:
            val = n * (n + 1) // 2
        elif sides == 4:
            val = n * n
        elif sides == 5:
            val = n * (3 * n - 1) // 2
        elif sides == 6:
            val = n * (2 * n - 1)
        elif sides == 7:
            val = n * (5 * n - 3) // 2
        elif sides == 8:
            val = n * (3 * n - 2)
        
        if val >= 10000:
            break
        if val >= 1000:
            prefix = val // 100
            if prefix not in nums:
                nums[prefix] = []
            nums[prefix].append(val)
        n += 1
    return nums

def find_cycle(chain, remaining, polygonals, start_prefix):
    if not remaining:
        if chain[-1] % 100 == start_prefix:
            return chain
        return None
    
    last_suffix = chain[-1] % 100
    if last_suffix < 10:
        return None
    
    for poly_type in remaining:
        if last_suffix in polygonals[poly_type]:
            for num in polygonals[poly_type][last_suffix]:
                result = find_cycle(chain + [num], remaining - {poly_type}, polygonals, start_prefix)
                if result:
                    return result
    return None

def solution():
    polygonals = {i: generate_polygonal(i) for i in range(3, 9)}
    
    for prefix, nums in polygonals[8].items():
        for num in nums:
            result = find_cycle([num], {3, 4, 5, 6, 7}, polygonals, prefix)
            if result:
                return sum(result)
    return None

if __name__ == "__main__":
    print(solution())  # Answer: 28684
